;N80 serial57k.asm -ofe rel

    area _CODE  ;To force SDAS output format

;RECEIVING AND SENDING RS232 DATA @57600 BITS/S  ON A STANDARD MSX 3.58MHz 
;CPU                   Z80
;FNAME                 "RS232.BIN"

;VOICEAQ:              EQU     #F975            ;BUFFER TO OCCUPY IN SYSTEM AREA: DO NOT USE PLAY...

;MSX .BIN HEADER
;DB                    #FE
;DW                    START,  END, START

;ORG                   VOICEAQ
;START:

;TRANSFER 'BC' BYTES FROM JOY2, 'UP', PIN1 TO (HL)
;MSX, Z80 3.58MHz 57600bps
;SETS CARRY BIT ON ERROR. A HOLDS ERROR CODE:
;A=1 RS232 LINE NOT HIGH,A=2 STARTBIT TIMEOUT

;unsigned char SerialReceive57k(byte* address, int length)
;HL=address, DE=length

_SerialReceive57k::
	ld b,d
	ld c,e
	DI			;NO INTERRUPTS, TIME CRITICAL ROUTINE
	LD	A,#0F	;PSG REGISTER 15, SELECT JOYSTICK PORT 2
	OUT	(#A0),A
	IN	A,(#A2)
	res	6,A		;SELECT JOY2    ;!!!
	OUT	(#A1),A

	LD	A,C	; FAST LOOP WITH BC (GRAUW, FAST LOOPS)
	DEC	BC	; COMPENSATION FOR THE CASE C=0
	INC	B
	LD	C,B	; SWAP B AND C FOR LOOP STRUCTURE
	LD	B,A

	LD	A,#0E	;SET PSG #14
	OUT	(#A0),A
	LD	E,#01	;FOR FASTER 'AND' OPERATION 'AND r'(5) VS. 'AND n'(8)
	IN	A,(#A2)
	AND	E
	JR	NZ,_FIRSTSTARTBIT	;RS232 LINE SHOULD BE HIGH, OTHERWISE STOP
	LD	A,#01	;ERROR, RS232 LINE NOT READY
	SCF
	EI
	RET
;THE NEXT PART IS TIME CRITICAL. EVERY CYCLE COUNTS
_FIRSTSTARTBIT:			;WAIT FOR FIRST STARTBIT
	;ld      d,b
	;ld      e,c
	push	bc
	ld	bc,0099h
_rfsb:
	IN	A,(#A2)
	AND	E
	;JP      NZ,_FIRSTSTARTBIT
	JP	z,_READFIRSTBIT	;START READING BIT0, COMPENSATED FOR 12 CYCLES, 1 JP
	in	f,(c)
	jp	p,_rfsb
	in	a,(#a2)
	and	e
	jp	z,_READFIRSTBIT
	djnz	_rfsb
	ld	a,2
	pop	bc
	scf
	ei
	ret

;_STARTBIT:
	IN	A,(#A2)	;WAIT FOR THE HIGH->LOW TRANSITION (STARTBIT)
	AND	E
	JP	Z,_READBITS
	IN	A,(#A2)	;WAIT FOR THE HIGH->LOW TRANSITION (STARTBIT)
	AND	E
	JP	Z,_READBITS
	IN	A,(#A2)	;WAIT FOR THE HIGH->LOW TRANSITION (STARTBIT)
	AND	E
	JP	Z,_READBITS
	IN	A,(#A2)	;WAIT FOR THE HIGH->LOW TRANSITION (STARTBIT)
	AND	E
	JP	Z,_READBITS
	LD	A,#02	;ERROR, STARTBIT TIMEOUT
	SCF
	EI
	RET
_READBITSNEXTBLOCK:
	INC	HL
	DEC	C
	JR	NZ,_INITBITLOOP	;NEXT BLOCK UNLESS WE ARE DONE (C=0)
	JP	_EXIT
_READBITSNEXTBYTE:
	INC	HL
	NOP		;DUMMY
	JR	_INITBITLOOP
_READBITS:
	IN	A,(#A2)	;DUMMY
_READFIRSTBIT:	;ALT TIMING TO COMPENSATE FOR 1 JP
	;ADD     A,#00            ;DUMMY
	;NOP     ;DUMMY
	pop	bc
_INITBITLOOP:
	LD  D,B
	LD	B,#08
_BITLOOPR:
	INC	HL	;DUMMY
	DEC	HL	;DUMMY
	IN	A,(#A2)
	RRCA		;SHIFT DATA BIT (0) -> CARRY
	RR	(HL)		;SHIFT CARRY -> [HL]
	DJNZ	_BITLOOPR
	LD	B,D
	DJNZ	_STARTBITNEXTBYTE	;NEXT BYTE, SKIP STOPBIT AND WAIT FOR STARTBIT
	NOP		;DUMMY
_STARTBITNEXTBLOCK:
	IN	A,(#A2)	;WAIT FOR THE HIGH->LOW TRANSITION (STARTBIT)
	AND	E
	JP	Z,_READBITSNEXTBLOCK
	IN	A,(#A2)	;WAIT FOR THE HIGH->LOW TRANSITION (STARTBIT)
	AND	E
	JP	Z,_READBITSNEXTBLOCK
	IN	A,(#A2)	;WAIT FOR THE HIGH->LOW TRANSITION (STARTBIT)
	AND	E
	JP	Z,_READBITSNEXTBLOCK
	IN	A,(#A2)	;WAIT FOR THE HIGH->LOW TRANSITION (STARTBIT)
	AND	E
	JP	Z,_READBITSNEXTBLOCK
	DEC	C	;POSTPONED CHECK
	JR	Z,_EXIT	;IF C=0, WE ARE DONE SO EXIT OTHERWISE ERROR
	LD	A,#02	;	ERROR STARTBIT TIMEOUT
	SCF
	EI
	RET
_STARTBITNEXTBYTE:
	IN	A,(#A2)	;WAIT FOR THE HIGH->LOW TRANSITION (STARTBIT)
	AND	E
	JP	Z,_READBITSNEXTBYTE
	IN	A,(#A2)	;WAIT FOR THE HIGH->LOW TRANSITION (STARTBIT)
	AND	E
	JP	Z,_READBITSNEXTBYTE
	IN	A,(#A2)	;WAIT FOR THE HIGH->LOW TRANSITION (STARTBIT)
	AND	E
	JP	Z,_READBITSNEXTBYTE
	IN	A,(#A2)	;WAIT FOR THE HIGH->LOW TRANSITION (STARTBIT)
	AND	E
	JP	Z,_READBITSNEXTBYTE
	LD	A,#02
	SCF
	EI
	RET
_EXIT:
	XOR	A	;RESET CARRY
	EI
	RET


;SEND 'BC' BYTES FROM [HL] TO PIN6, JOY2
;MSX, Z80 3.58MHz 57600bps

;void SerialSend(byte* address, int length)
;HL=address, DE=length

_SerialSend57k::
    ld b,d
	ld c,e
	DI		;NO INTERRUPTS
	LD	A,#0F	;SELECT PSG REG #15
	OUT	(#A0),A
	IN	A,(#A2)	;SAVE VALUE
	PUSH	AF
	res	6,A		;JOY2   ;!!!
	RES	0,A		;TRIG1 LOW  ;!!!
	LD	E,A		;0V VALUE (0) IN E
	SET	0,A		;TRIG1 HIGH ;!!!
	LD	D,A		;5V VALUE (1) IN D
_BYTELOOP:
	PUSH	BC
	LD	A,E
_STARTBIT:
	OUT	(#A1),A
	LD	C,(HL)
	LD	B,#08
_BITLOOP:
	RRC	C
;ASSUME BIT=1
	LD	A,D
	JR	C,_SETBIT
;NO, BIT=0
	LD	A,E
_SETBIT:
	ADD	A,#00	;DUMMY
	OUT	(#A1),A
	DJNZ	_BITLOOP
	LD	A,E
	POP	BC
	DEC	BC
	NOP		;DUMMY
	ADD	A,#00	;DUMMY
_STOPBIT:
	LD	A,D
	OUT	(#A1),A
	INC	HL
	LD	A,B
	OR	C
	NOP		;DUMMY
	JP	NZ,_BYTELOOP
;_EXIT2:
	NOP		;DUMMY
	POP	AF
	OUT	(#A1),A
	EI
	RET
